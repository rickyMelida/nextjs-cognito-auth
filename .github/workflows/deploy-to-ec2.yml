name: Deploy to EC2

on:
  workflow_run:
    workflows: ["Build and Push to ECR"]
    types:
      - completed
    branches:
      - master

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: foler/crystal-manager-app

jobs:
  deploy:
    runs-on: ubuntu-latest
    # Solo ejecutar si el workflow anterior fue exitoso
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script: |
            # Variables
            AWS_REGION="${{ env.AWS_REGION }}"
            ECR_REPOSITORY="${{ env.ECR_REPOSITORY }}"
            IMAGE_TAG="${{ github.event.workflow_run.head_sha }}"
            CONTAINER_NAME="nextjs-cognito-app"
            
            # Obtener Account ID automÃ¡ticamente
            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            ECR_REGISTRY="$ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com"
            
            echo "ğŸš€ Desplegando imagen: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
            
            # Autenticarse con ECR
            echo "ğŸ” Autenticando con ECR..."
            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_REGISTRY
            
            # Detener y eliminar contenedor existente si existe
            echo "ğŸ›‘ Deteniendo contenedor existente..."
            docker stop $CONTAINER_NAME 2>/dev/null || true
            docker rm $CONTAINER_NAME 2>/dev/null || true
            
            # Descargar la imagen mÃ¡s reciente
            echo "ğŸ“¥ Descargando imagen..."
            docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            
            # Ejecutar el nuevo contenedor
            echo "ğŸƒ Iniciando nuevo contenedor..."
            docker run -d \
              --name $CONTAINER_NAME \
              --restart unless-stopped \
              -p 3000:3000 \
              -e NODE_ENV=production \
              $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            
            # Esperar unos segundos para que el contenedor inicie
            echo "â³ Esperando que el contenedor inicie..."
            sleep 10
            
            # Verificar que el contenedor estÃ¡ ejecutÃ¡ndose y saludable
            echo "âœ… Verificando estado del contenedor..."
            if docker ps | grep $CONTAINER_NAME; then
              echo "âœ… Contenedor iniciado correctamente"
              
              # Health check opcional
              echo "ğŸ” Verificando health check..."
              if curl -f http://localhost:3000 >/dev/null 2>&1; then
                echo "âœ… AplicaciÃ³n responde correctamente"
              else
                echo "âš ï¸  AplicaciÃ³n no responde en el puerto 3000"
              fi
            else
              echo "âŒ Error: El contenedor no estÃ¡ ejecutÃ¡ndose"
              echo "ğŸ“‹ Logs del contenedor:"
              docker logs $CONTAINER_NAME --tail 50
              exit 1
            fi
            
            # Limpiar imÃ¡genes antiguas (conservar Ãºltimas 3)
            echo "ğŸ§¹ Limpiando imÃ¡genes antiguas..."
            docker images $ECR_REGISTRY/$ECR_REPOSITORY --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | tail -n +2 | head -n -3 | awk '{print $1}' | xargs -r docker rmi || true
            
            echo "ğŸ‰ Despliegue completado exitosamente!"
            echo "ğŸŒ AplicaciÃ³n disponible en: http://$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4):3000"
